---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by lixy.
--- DateTime: 2018/7/24 17:11
---

local csjon = require("cjson")

-- 用户名称 UUID的命名空间
local uuid_help = require "resty.utils.uuid_help":new(ZS_USER_NAME_SPACE)

local _M = {}

function _M.debug_data (data)
    if type(data) ~= 'table' then
        return
    end

    for k, v in pairs(data) do
        ngx.log(ngx.DEBUG, '[', k, '] -> [', tostring(v), ']')
    end
end

function _M.check_keys(data, keys)
    if not keys or #keys <= 0 then
        return true
    end
    if not data then
        return nil, "请求参数为空."
    end
    local err = ""
    for k, v in pairs(keys) do
        if not data[v] or type(data[v]) == 'userdata' then
            err = err .. string.format("[%s] ", v)
        end
    end
    if err ~= '' then
        err = err .. "错误."
        return nil, "参数 " .. err
    else
        return true
    end
end

function _M.json_encode(buf)
    return csjon.encode(buf)
end

function _M.json_decode(buf)
    if 'string' ~= type(buf) then
        return nil, "JSON decode failed, data type is not string: " .. type(buf)
    end
    local ok, data = pcall(csjon.decode, buf)
    if ok then
        return data
    else
        return nil, "JSON decode failed, buf=" .. buf
    end
end

function _M.sql_append(s, key, val, symbol, prefix)
    if val == '' then
        val = nil
    end
    if val then
        if string.len(s) > 0 then
            s = s .. " " .. prefix .. " "
        end
        s = s .. key .. symbol .. "'" .. val .. "'"
    end
    return s
end

function _M.count_table_keys(tb)
    local count = 0
    for k, v in pairs(tb) do
        count = count + 1
    end
    return count
end

--[[
    将table的KEY按照字母大小排序
]]
function _M.sort_table_key(t_src)
    local t_temp = {}
    for k, v in pairs(t_src) do
        table.insert(t_temp, k)
    end

    table.sort(t_temp, function(v1, v2)
        for i = 1, math.max(string.len(v1), string.len(v2)), 1 do
            local c1 = string.gsub(v1, i, 1)
            local c2 = string.gsub(v2, i, 1)
            if c1 > c2 then
                return false
            elseif c1 < c2 then
                return true
            end
        end
        return false
    end)
    return t_temp
end

function _M.url_encode_sort(t_src)
    local keys = _M.sort_table_key(t_src)
    local buf_src = ""
    for i = 1, #keys do
        local key_item = keys[i]
        if buf_src ~= "" then
            buf_src = buf_src .. "&"
        end
        buf_src = buf_src .. key_item .. "=" .. t_src[key_item]
    end
    return buf_src
end

function _M.url_encode(t_src)
    local buf = ""
    for k, v in pairs(t_src) do
        if buf ~= "" then
            buf = buf .. "&"
        end
        buf = buf .. k .. "=" .. v
    end
    return buf
end

function _M.str_to_timestamp(s)
    local s_fmt1 = 'YYYY-mm-dd HH:MM:SS'
    local s_fmt2 = 'YYYYmmddHHMMSS'
    local len = string.len(s)

    local index = nil
    if len == string.len(s_fmt1) then
        index = { 1, 6, 9, 12, 15, 18 }
    elseif len == string.len(s_fmt2) then
        index = { 1, 5, 7, 9, 11, 13 }
    else
        return nil, '格式错误, 支持格式:' .. s_fmt1 .. ',' .. s_fmt2
    end
    if not index then
        return nil
    end

    local t = {
        year = string.sub(s, index[1], index[1]+3),
        month = string.sub(s, index[2], index[2]+1),
        day = string.sub(s, index[3], index[3]+1),
        hour = string.sub(s, index[4], index[4]+1),
        minute = string.sub(s, index[5], index[5]+1),
        second = string.sub(s, index[6], index[6]+1),
    }
    return os.time(t)
end

--[[
-- makePassword 创建user_uuid namespace 下的94进制密码,用于注册或者登录时的密码处理
-- 减少 系统存储用户密码长度 该客户端 密码为处理 sha256
-- example
 	local password = 'xxxxx'
 	local pwd_94 = _M.makePassword(password)
-- @param  _password 密码
-- @return 密码94进制字符串 不可用于url传输(可通过编码之后进行传输)
--]]
_M.make_password = function(_password)
    if not _password then
        return nil
    end
    local pwd = uuid_help:get94(_password)
    -- 94进制的数据中存在' " 两个字符串, 所以系统需要将字符串转译一次
    pwd = string.gsub(pwd,"\\","#")
    pwd = string.gsub(pwd,"'","#")
    ngx.log(ngx.ERR, 'pwd:', pwd)
    return pwd
end

--[[
    @brief:
            判断闰年还是平年
    @params:
            year 指定年
    @return:
            1 闰年
            0 平年
            nil 错误
]]
_M.what_year = function (year)
    local year = tonumber(year)
    if not year or year <= 0 then
        return nil, 'year 参数错误'
    end

    local is  = false
    if (year % 4 == 0 and year % 100 ~= 0) or (year % 400 == 0) then
        is = 1
    else
        is = 0
    end

    return is
end

--[[
    @brief:
            当月有多少天
    @params:
            year 指定年
            month 指定月
    @return:
            num 天数
            nil 错误
]]
_M.days_in_month = function (year, month)
    local year = tonumber(year)
    if not year or year <= 0 then
        return nil, 'year 参数错误'
    end

    local month = tonumber(month)
    if not year then
        return nil, 'month 参数错误'
    end
    if month < 1 or month > 12 then
        return nil, 'month 参数错误'
    end

    local is, err = _M.what_year(year)
    if not is then
        return nil, err
    end

    local days = 0
    if month == 2 then
        if is == 1 then
            days = 29
        else
            days = 28
        end
    else
        if month == 1 or month == 3 or month == 5 or month == 7
                or month == 8 or month == 10 or month == 12 then
            days = 31
        else
            days = 30
        end
    end

    return days
end

--[[
    @brief:
            解析时间   2018-10-31
    @params:
            date 2018-10-31
    @return:
            year
            month
            day

            nil
]]
_M.parse_date = function (date)
    if not date then
        return nil, 'date 参数错误.'
    end

    local l_year = nil
    local l_mon = nil
    local l_day = nil
    local s, e = string.find(date, '-')
    if not s then
        return nil, 'date 参数错误.'
    end

    l_year = string.sub(date, 1, (s - 1))
    local sub_str = string.sub(date, (s + 1), #date)

    local s, e = string.find(sub_str, '-')
    if not s then
        return nil, 'date 参数错误.'
    end

    l_mon = string.sub(sub_str, 1, (s - 1))
    l_day = string.sub(sub_str, (s + 1), #sub_str)

    local l_year = tonumber(l_year)
    local l_mon = tonumber(l_mon)
    local l_day = tonumber(l_day)
    if l_year == nil or l_mon == nil or l_day == nil then
        return nil, 'date 参数错误.'
    end

    local is, err = _M.what_year(l_year)
    if not is then
        return nil, 'date 参数错误. -> ' .. err
    end

    if l_mon < 1 or l_mon > 12 then
        return nil, 'date 参数错误.'
    end

    local days_max, err = _M.days_in_month(l_year, l_mon)
    if not days_max then
        return nil, err
    end

    if l_day <= 0 or l_day > days_max then
        return nil, 'date 参数错误.'
    end

    return l_year, l_mon, l_day
end

--[[
    @brief:
            计算包含指定天在内的前n天日期
    @params:
            day 指定日期 2018-11-01
            num 前num天
    @return:
           [
              "2018-11-01"，
              "2018-10-31"
           ]
]]
_M.calc_date = function(day, num)
    if tonumber(num) == nil or  tonumber(num) < 1 then
        return nil, 'num 参数错误.'
    end

    if not day then
        return nil, 'day 参数错误.'
    end

    local l_year, l_month, l_day = _M.parse_date(day)
    if not l_year then
        return nil, '解析日期错误: -> ' .. day
    end

    local is, err = _M.what_year(l_year)
    if not is then
        return nil, "解析年错误: -> " .. err
    end

    local infos = {}
    local last_year = l_year
    local last_month = l_month
    local last_day = l_day
    table.insert(infos, string.format("%04d-%02d-%02d", last_year, last_month, last_day))
    for i = 2, num do
        last_day = l_day - 1
        if last_day == 0 then
            last_month = l_month - 1
            if last_month == 0 then
                last_month = 12
                last_year = l_year - 1
            end
            local days_max, err = _M.days_in_month(last_year, last_month)
            if not days_max then
                return nil, '获取指定日期天数错误: -> ', err
            end
            last_day = days_max
        end
        local info = string.format("%04d-%02d-%02d", last_year, last_month, last_day)

        table.insert(infos, info)

        --重置计算日期
        l_year = last_year
        l_month = last_month
        l_day = last_day
    end

    ngx.log(ngx.ERR, '[date]: ', _M.json_encode(infos))
    return infos
end

--[[
    @brief:
            计算包含指定天在内的前n月
    @params:
            day 指定日期 2018-11
            num 前num月
    @return:
           [
                "2018-11",
                "2018-10"
           ]
]]
_M.calc_month = function (year, month, num)
    if not year or not month or tonumber(num) == nil or tonumber(num) <= 0 then
        return nil, '参数错误.'
    end

    local l_year = tonumber(year)
    local l_month = tonumber(month)
    local num = tonumber(num)

    if l_year < 1970 then
        return nil, 'year 参数错误.'
    end

    if l_month < 1 or l_month > 12 then
        return nil, 'month 参数错误.'
    end

    local last_year = l_year
    local last_month = l_month
    local infos = {}
    local date = string.format('%04d-%02d', last_year, last_month)
    table.insert(infos, date)
    for i = 2, num do
        last_month = l_month - 1
        if last_month == 0 then
            last_month = 12
            last_year = l_year - 1
        end

        date = string.format('%04d-%02d', last_year, last_month)
        table.insert(infos, date)

        l_year = last_year
        l_month = last_month
    end

    return infos
end

--[[
    @brief:
            计算包含指定天在内的前n周
    @params:
            day 指定日期 2018-11-1
            num 前num周
    @return:
           [
                "2018-44",
                "2018-43"
           ]
]]
_M.calc_week = function (day, num)
    if tonumber(num) == nil or  tonumber(num) < 1 then
        return nil, 'num 参数错误.'
    end

    if not day then
        return nil, 'day 参数错误.'
    end

    local l_year, l_month, l_day = _M.parse_date(day)
    if not l_year then
        return nil, '解析日期错误: -> ' .. day
    end

    local is, err = _M.what_year(l_year)
    if not is then
        return nil, "解析年错误: -> " .. err
    end

    local total_days = 0
    for i = 1, l_month - 1 do
        local days_max, err = _M.days_in_month(l_year, i)
        if not days_max then
            return nil, '计算天数错误. err: ' .. err
        end
        total_days = total_days + days_max
    end
    total_days = total_days + l_day

    local l_week = 0
    local t1, t2 = math.modf(total_days / 7)
    if tonumber(t2) ~= 0 then
        l_week = tonumber(t1) + 1
    else
        l_week = tonumber(t1)
    end

    local infos = {}
    local last_year = l_year
    local last_week = l_week
    local info = string.format('%04d-%02d', last_year, l_week)
    table.insert(infos, info)
    for i = 2, num do
        last_week = l_week - 1
        if last_week == 0 then
            last_year = l_year - 1
            local max_days = 0
            local is = _M.what_year(last_year)
            if is then
                max_days = 366
            else
                max_days = 365
            end
            local t1, t2 = math.modf(max_days / 7)
            if tonumber(t2) ~= 0 then
                last_week = tonumber(t1) + 1
            else
                last_week = tonumber(t1)
            end
        end

        info = string.format('%04d-%02d', last_year, last_week)
        table.insert(infos, info)

        l_year = last_year
        l_week = last_week
    end

    return infos
end

--[[
    @brief:
            计算包含指定天在内的前n年
    @params:
            year 指定日期 2018
            num 前num年
    @return:
           [
                "2018",
                "2017"
           ]
]]
_M.calc_year = function (year, num)
    if not year  or tonumber(num) == nil or tonumber(num) <= 0 then
        return nil, '参数错误.'
    end

    local l_year = tonumber(year)
    local num = tonumber(num)

    if l_year < 1970 then
        return nil, 'year 参数错误.'
    end

    local infos = {}
    local last_year = l_year
    local info = string.format('%04d', last_year)
    table.insert(infos, info)
    for i = 2, num do
        last_year = l_year - 1
        info = string.format('%04d', last_year)
        table.insert(infos, info)

        l_year = last_year
    end

    return infos
end

_M.reverseTable = function (tab)
    local tmp = {}
    for i = 1, #tab do
        tmp[i] = table.remove(tab)
    end

    return tmp
end

_M.get_kv_table_length = function(table)
    local len = 0
    for k,v in pairs(table) do
        len = len+1
    end
    return len
end

--[[
    @brief:
            http请求 capture请求接口
    @params:
            url 请求地址
                外网地址必须以http | https 开头 其它地址认为是内部地址
            method get 或 post  请求
            params 请求参数   表结构
            header http 请求header  内部地址不支持
            ssl  是否是ssl协议
            t_timeout 超时  默认15s 内部地址不支持
    @return:
            http 结果
    @example:
            http请求
                local res, err = request('http://www.qq.com')
                
            capture内部请求
                local res, err = request('/test/test_match.do?url=http://www.baidu.com')
]]
_M.request = function (url, method, params, header, ssl, t_timeout)
    if not method then
        method = 'get'
    end

    if method ~= 'get' and method ~= 'post' and method ~= 'GET' and method ~= 'POST' then
        return nil, '方法不支持.只支持 get | post |GET | POST'
    end

    local regex = '(https?|ftp|file)://[-A-Za-z0-9+&@#/%?=~_|!:,.;]+[-A-Za-z0-9+&@#/%=~_|]'
    local res, err = ngx.re.match(url, regex)
    if res[0] and string.sub(url, 1, 1) == string.sub(res[0], 1, 1) then
        --外网地址
        local http_manager = require("resty.utils.http_manager")
        if method == 'get' or method == 'GET' then
            return http_manager.request_get(url, params, header, ssl, t_timeout)
        elseif method == 'post' or method == 'POST' then
            return http_manager.request_post(url, params, header, ssl, t_timeout)
        end
    else
        if method == 'get' or method == 'GET' then
            method = ngx.HTTP_GET
        elseif method == 'post' or method == 'POST' then
            method = ngx.HTTP_POST
        end

        return ngx.location.capture(url, {
            method = method,
            args = params,
        })
    end
end


--[[
    @brief:  将日志内容添加到ctx表中
    @params: log_type 日志类型 add/del/modify/login/logout
             log_content 日志内容
    @return: nil
]]
_M.add_log_into_ctx = function (log_type, log_content)
    local str = 'add,del,modify,login.logout'
    local start = string.find(str, log_type)
    if not start then
        ngx.log(ngx.ERR, 'add_log_into_ctx ----> 添加日志类型错误, log_type: ' .. log_type)
        return nil
    end
    ngx.ctx.log_param = {
        log_type = log_type,
        log_content = log_content
    }
end


--[[
    @brief:  将字符串按分隔符分割
    @params: input 输入字符串
             delimiter 分隔符
    @return: array
]]
_M.split = function (input, delimiter)
    input = tostring(input)
    delimiter = tostring(delimiter)
    if (delimiter=='') then return false end
    local pos,arr = 0, {}
    -- for each divider found
    for st,sp in function() return string.find(input, delimiter, pos, true) end do
        table.insert(arr, string.sub(input, pos, st - 1))
        pos = sp + 1
    end
    table.insert(arr, string.sub(input, pos))
    return arr
end


--[[
    @brief:  将字符串数组按分隔符相加
    @params: arr 数组
             delimiter 分隔符
    @return: str
]]
_M.join = function(arr, delimiter)
    delimiter = tostring(delimiter)
    local str = ''
    for k, v in pairs(arr) do
        str = str .. delimiter  .. v
    end
    if (delimiter=='') then return str end
    return string.sub(str, 2)
end


--[[
    @brief:  字符串用逗号隔开，给字符串元素加引号
    @params: str 字符串

    @return: str
    @use:
             local str = '111,222,333'
             local output = add_quot_for_ele(str)
             print(output)  -- '"111","222","333"'
]]
_M.add_quot_for_ele = function(str)
    local _arr = _M.split(str, ',')
    for k, v in pairs(_arr) do
        _arr[k] = '"' .. v ..'"'
    end
    return _M.join(_arr, ',')
end


--[[
    @brief:  判断参数是否存在，并且不为空字符串
    @params: param 参数

    @return: true 存在，false 不存在
    @use:

]]
_M.is_param_exit = function (param)
    return param and param ~= ''
end

return _M