---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by lixy.
--- DateTime: 2018/8/22 8:59
---

local utils = require("resty.utils.utils")
local resty_http = require("resty.http")

local CONTENT_TYPE = {
    URLENCODE = "application/x-www-form-urlencoded",
    JSON = "application/json",
    FORM = "multipart/form-data"
}

local function explode (_str, seperator)
    local pos, arr = 0, {}
    for st, sp in function()
        return string.find(_str, seperator, pos, true)
    end do
        table.insert(arr, string.sub(_str, pos, st - 1))
        pos = sp + 1
    end
    table.insert(arr, string.sub(_str, pos))
    return arr
end

local _M = {}


--[[
    获取请求参数
]]
function _M.get_req_args()
    local request_params = ngx.ctx.request_params
    if request_params then
        return request_params
    end

    local method = ngx.req.get_method()
    local args = nil
    if method == "GET" then
        args = ngx.req.get_uri_args()
    elseif method == "POST" then
        local headers = ngx.req.get_headers() or {}
        local content_type = headers["Content-Type"] or ""

        ngx.req.read_body()
        local body = ngx.req.get_body_data()
        if body then
            body = ngx.unescape_uri(body)
        end

        --ngx.log(ngx.DEBUG, "===== 解析请求参数: \n content_type= ", content_type, "\n body=", body)
        args = {}
        --application/x-www-form-urlencoded
        if string.sub(content_type, 1, string.len(CONTENT_TYPE.URLENCODE)) == CONTENT_TYPE.URLENCODE then
            args = ngx.decode_args(body)
            if not args then
                ngx.log(ngx.ERR, "Parse body failed, Content-Type and body mismatch, method=", method, ", Content-Type=", content_type, ", body=", body)
            end
        elseif string.sub(content_type, 1, string.len(CONTENT_TYPE.JSON)) == CONTENT_TYPE.JSON then
            args = utils.json_decode(body)
            if not args then
                ngx.log(ngx.ERR, "Parse body failed, Content-Type and body mismatch, method=", method, ", Content-Type=", content_type, ", body=", body)
            end
            --elseif find_substr(content_type, "multipart/form-data;") then
        elseif string.sub(content_type, 1, string.len(CONTENT_TYPE.FORM)) == CONTENT_TYPE.FORM then
            local boundary = "--" .. string.sub(headers["content-type"], 31)
            local body_data_table = explode(tostring(body), boundary)

            local first_string = table.remove(body_data_table, 1)
            local last_string = table.remove(body_data_table)
            for i, v in ipairs(body_data_table) do
                local start_pos, end_pos, capture, capture2 = string.find(v, 'Content%-Disposition: form%-data; name="(.+)"\r\n\r\n(.+)\r\n')
                if start_pos then
                    args[capture] = capture2
                end
            end
        else
            --ngx.log(ngx.ERR, "Unknown request Content-Type, Content-Type=", content_type, ", method=", method, ", body=", body)
            args = utils.json_decode(body)
            if not args then
                args = ngx.decode_args(body)
            else
            end
        end
    else
        ngx.log(ngx.ERR, "Unknown request, method=", method)
        return nil
    end
    if args and type(args) == 'table' then
        --对空字符串设置为nil默认值
        for k, v in pairs(args) do
            if v == '' then
                args[k] = nil
            end
        end
    else
        args = nil
    end

    ngx.ctx.request_params = args
    return args
end



--[[
    发送HTTP GET请求
]]
function _M.request_get(url, params, header, ssl, t_timeout)
    local http = resty_http.new()
    http:set_timeout(t_timeout or 15000)

    local req_url = url
    if params then
        local buf = ""
        if header and header["Content-Type"] == "application/x-www-form-urlencoded" then
            buf = ngx.encode_args(params)
        else
            for k, v in pairs(params) do
                if buf ~= "" then
                    buf = buf .. "&"
                end
                buf = buf .. k .. "=" .. v
            end
        end
        req_url = url .. "?" .. buf
    end

    return http:request_uri(req_url, {
        method = "GET",
        ssl_verify = (ssl and true) or false,
        headers = header
        --headers = { ["Content-Type"] = "application/json" },
        --body = utils.json_encode(params)
    })
end





--[[
    发送HTTP POST请求
]]
function _M.request_post(url, params, header, ssl, t_timeout)
    local http = resty_http.new()
    http:set_timeout(t_timeout or 15000)

    local body = nil
    if params then
        if header and header["Content-Type"] then
            local content_type = header["Content-Type"]
            if string.sub(content_type, 1, string.len(CONTENT_TYPE.URLENCODE)) == CONTENT_TYPE.URLENCODE then
                --body = ngx.encode_args(params)
                body = utils.url_encode_sort(params)
            elseif string.sub(content_type, 1, string.len(CONTENT_TYPE.JSON)) == CONTENT_TYPE.JSON then
                body = utils.json_encode(params)
            else
                body = utils.url_encode_sort(params)
            end
        else
            body = utils.url_encode_sort(params)
        end
    end
    --ngx.log(ngx.ERR, "================= HTTP 请求:\n\t** url: ", url, "\n\t** body: ", body)
    return http:request_uri(url, {
        method = "POST",
        ssl_verify = (ssl and true) or false,
        headers = header,
        --headers = { ["Content-Type"] = "application/x-www-form-urlencoded" },
        --headers = { ["Content-Type"] = "application/json" },
        body = body
    })
end

return _M