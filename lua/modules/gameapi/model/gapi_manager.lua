---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by lixy.
--- DateTime: 2018/5/12 9:34
---

local sys = sys
local utils = sys.utils
local http = require("resty.http")

local time_manager = require("common.time_manager")

local api_def = require("gameapi.conf.api_def")

-- local time_help = require 'resty.utils.time.time_help'
-- local incr_help = require("resty.utils.incr_help")
-- local gapi_conf = require("gapi_platform.bundles.gapi_conf")

-- local user_dao = require "gapi_platform.model.user_dao"
-- local biz_dao = require("bizorg.model.bizorg_dao")
-- local game_platform_dao = require "gapi_platform.model.game_platform_dao"
-- local bizorg_dao = require "bizorg.model.bizorg_dao"
-- local game_platform_dao = require("gapi_platform.model.game_platform_dao")


local _M = {}

--[[
    创建唯一事务ID
]]
_M.create_trans_id = function(platform_code, user_id, agent)
    local trans_id = time_manager.uuid()
    --if "BZ_GAME_AG" == platform_code then
    --    if string.len(trans_id) < 16 then
    --        trans_id = trans_id .. incr_help.get_time_union_id()
    --    end
    --    local len = string.len(trans_id)
    --    trans_id = string.sub(trans_id, (len - 16) + 1)
    --end
    if "BZ_GAME_KY" == platform_code or "BZ_GAME_KY_XSJ" == platform_code or "BZ_GAME_KY_LY" == platform_code then
        local res = time_help.get_remote_system_time()
        if not res then
            ngx.log(ngx.ERR, 'time_help.get_system_time失败, 订单号生成失败.')
            return nil
        end
        local timems = string.format('%03d', res[2])
        trans_id = string.format("%s%s%s%s", agent.agent, os.date("%Y%m%d%H%M%S", tonumber(res[1])), timems, user_id)
        ngx.log(ngx.DEBUG, 'trans_id: ', trans_id)
    elseif "BZ_GAME_LC" == platform_code then
        trans_id = string.format("%s%s%s%s",agent.agent_id,os.date("%Y%m%d%H%M%S"),"000",user_id)
        --trans_id = string.format("%s%s%s%s", agent.agent, os.date("%Y%m%d%H%M%S", tonumber(res[1])), timems, user_id)
        ngx.log(ngx.DEBUG, 'trans_id: ', trans_id)
    end
    return trans_id
end


--[[
    capture 系统API
    @param: [method] 接口名
    @param: [data] 请求参数
    @return: {code=200, msg="", data={}}
]]

function _M.capture_api(method, data)
    local url = gapi_conf.get_method_url(method)
    local res, err = sys.utils.capture(ngx.HTTP_POST, url, data)
    if not res then
        ngx.log(ngx.ERR, "CAPTURE ERROR: ", err, ', url=', url)
        return { code = sys.ERR_CODE.SYS_ERR, msg = err }
    end
    if not res.code then
        ngx.log(ngx.ERR, "CAPTURE response format ERROR:", sys.utils.json_encode(res))
        return { code = sys.ERR_CODE.SYS_ERR, msg = 'CAPTURE返回消息格式错误', res }
    end
    return res
end


function _M.capture_multi(url, app_id, biz_user_id, biz_data, lst_platform)
    if #lst_platform <= 0 then
        return nil, "没有查询到用户的游戏平台账户信息"
    end

    -- 保存返回消息
    local result = {}

    -- 保存请求平台信息
    local list_id = {}

    -- 保存请求参数
    local list_params = {}
    
    --生成capture_mulit参数数组
    for i = 1, #lst_platform, 1 do
        local body = biz_data
        body.game_platform_code = lst_platform[i].account_type
        
        local code, msg, data = _M.check_platform(app_id, biz_user_id, body.game_platform_code)
        if code == sys.ERR_CODE.SUCCESS then
            body.platform_state = tonumber(data.platform.platform_state)
            body.biz_account_state = tonumber(data.biz_account.account_state)
            body.agent = data.agent
            body.agent.self_configed = data.biz_account.self_configed
            body.self_configed = data.biz_account.self_configed

            local item = { url, { method = ngx.HTTP_POST, body = sys.utils.json_encode(body) } }
            table.insert(list_params, item)
            table.insert(list_id, body.game_platform_code)
        else
            result[body.game_platform_code] = {code = code, msg = msg or "系统错误"}
        end
    end
    
    if #list_params > 0 then
        local res = { ngx.location.capture_multi(list_params) }
        for i = 1, #res do
            local id = list_id[i] -- 请求对应平台ID
            local item = res[i]   -- 请求返回结果
            if ngx.HTTP_OK == item.status then
                local data = sys.utils.json_decode(item.body)
                if data then
                    result[id] = data
                else
                    ngx.log(ngx.ERR, string.format("CAPTURE MULTI 请求[%s]错误, JSON解析返回参数失败，body=%s, url=%s", id, item.body, url))
                    result[id] = { code = sys.ERR_CODE.SYS_ERR, msg = "系统错误", data = item.body }
                end
            else
                ngx.log(ngx.ERR, string.format("CAPTURE MULTI 请求[%s]错误, HTTP请求错误，status=%s, body=%s, url=%s", id, item.status, item.body, url))
                result[id] = { code = sys.ERR_CODE.SYS_ERR, msg = "系统错误", data = item.body }
            end
        end
    end
    return result
end


--[[
    @brief:  请求系统游戏平台接口，查询游戏平台配置数据，根据请求方式定义，如果是本地服务(和当前服务是同一个)
             则使用 capture 请求，如果是远程服务则使用 http 请求
    @param: 
        platform_id: 平台ID
        method: 接口名
        data: 请求参数
    @return: {code=200, msg="", data={}}
]]
function _M.request_api_platform(platform_id, method, data)
    data.platform_code = platform_id

    -- 获取平台接口所在服务器IP
    local sql = string.format("select server_addr, request_type from t_three_game_platform where platform_code = '%s' order by id_pk limit 1;", platform_id)
    local res, err = sys.db_mysql:exec_once(sql)
    if not res then
        ngx.log(ngx.ERR, '数据库错误. error=', err)
        return {code = sys.ERR_CODE.SYS_ERR, msg = '查询三方接口服务器地址失败.'}
    end
    if not res[1] then
        ngx.log(ngx.ERR, '查询查询三方接口服务器地址失败.')
        return {code = sys.ERR_CODE.SYS_ERR, msg = '查询三方接口服务器地址失败.'}
    end

    local server_addr = res[1].server_addr
    local request_type = res[1].request_type
    if not server_addr then
        ngx.log(ngx.ERR, '三方接口服务器IP错误 server_addr: ',server_addr )
        return {code = sys.ERR_CODE.SYS_ERR, msg = '查询三方接口服务器地址失败.'}
    end
    if not request_type or type(request_type) == 'userdata' then
        request_type = sys.basedef.REQUEST_TYPE.LOCAL
    end

    if request_type ~= sys.basedef.REQUEST_TYPE.REMOTE and request_type ~= sys.basedef.REQUEST_TYPE.LOCAL then
        ngx.log(ngx.ERR, '三方接口服务器访问方式错误 request_type: ',request_type )
        return {code = sys.ERR_CODE.SYS_ERR, msg = '系统错误.'}
    end

    local url = gapi_conf.get_method_url_3rd(method, platform_id)
    if request_type == sys.basedef.REQUEST_TYPE.REMOTE then
        url = server_addr .. url
    elseif request_type == sys.basedef.REQUEST_TYPE.LOCAL then
    end

    if request_type ~= sys.basedef.REQUEST_TYPE.LOCAL then
        local httpc = http.new()
        local timeout = 10000
        httpc:set_timeout(timeout)
        local res, err = httpc:request_uri(url, {
            method = "POST", -- 为空使用 GET 方法
            ssl_verify = false, -- 进行https访问
            body = sys.utils.json_encode(data),
        })

        if not res then
            ngx.log(ngx.ERR, '请求三方接口服务器错误. err: ', err)
            return {code = sys.ERR_CODE.SYS_ERR, msg = '请求三方接口服务器错误.'}
        end
        if res.status == 408 then
            ngx.log(ngx.ERR, '请求三方接口服务器超时.')
            return {code = sys.ERR_CODE.THIRD_PARTY_TIMEOUT, msg = '请求三方接口服务器超时.'}
        end
        if res.status ~= 200 then
            ngx.log(ngx.ERR, '请求三方接口服务器失败. status: ', res.status)
            return {code = sys.ERR_CODE.SYS_ERR, msg = '请求三方接口服务器失败.'}
        end

        local res_body, err = sys.utils.json_decode(res.body)
        if not res_body then
            ngx.log(ngx.ERR, '请求三方接口服务器结果错误. body: ', res.body)
            return {code = sys.ERR_CODE.SYS_ERR, msg = '请求三方接口服务器失败.'}
        end

        if not res_body.code then
            ngx.log(ngx.ERR, "请求三方接口服务器结果错误. body: ", res.body)
            return { code = sys.ERR_CODE.SYS_ERR, msg = '请求三方接口服务器失败.'}
        end

        return res_body
    else
        data.method = method
        local res, err = sys.utils.capture(ngx.HTTP_POST, url, data)
        if not res then
            ngx.log(ngx.ERR, "CAPTURE ERROR: platform_code=", platform_id, ", method=", method, ",url=", url, ",err=", err)
            return { code = sys.ERR_CODE.SYS_ERR, msg = err }
        end
        if not res.code then
            ngx.log(ngx.ERR, "CAPTURE response format ERROR:", sys.utils.json_encode(res))
            return { code = sys.ERR_CODE.SYS_ERR, msg = 'CAPTURE返回消息格式错误', data = res }
        end
        return res
    end
end




_M.user_exception_handler = function(id, params)
    ngx.log(ngx.ERR, "", id, ", params=", sys.utils.json_encode(params))
    if sys.basedef.ACCOUNT_ERR_STATE.BALANCE_REPAIRE_LOSE == params.err_state then
        --获取余额
        local data = {
            app_id = params.app_id,
            user_id = params.user_id,
            game_platform_code = params.platform_code,
            self_configed = params.self_configed,
        }

        local res, err = _M.request_api_platform(params.platform_code, gapi_conf.METHOD.GET_BALANCE, data)
        if not res then
            ngx.log(ngx.ERR, "获取余额错误:", err)
            return nil, "获取余额错误:" .. err
        end
        if 200 ~= res.code then
            ngx.log(ngx.ERR, "获取余额失败:", sys.utils.json_encode(res))
            return nil, "获取余额失败:" .. sys.utils.json_encode(res)
        end

        --下分
        local balance = tonumber(res.data.balance)
        if balance > 0 then
            ngx.log(ngx.ERR, "balance=", balance)
            local data = {
                app_id = params.app_id,
                user_id = params.user_id,
                game_platform_code = params.platform_code,
                amount = balance,
                currency_type = params.currency,
                self_configed = params.self_configed
            }

            local res, err = _M.request_api_platform(params.platform_code, gapi_conf.METHOD.TAKE_NOW, data)
            if not res then
                ngx.log(ngx.ERR, "下分错误:", err)
                return nil, "下分错误:" .. err
            end
            if 200 ~= res.code then
                ngx.log(ngx.ERR, "下分失败:", sys.utils.json_encode(res))
                return nil, "下分失败:" .. sys.utils.json_encode(res)
            end
        end

        local res, err = user_dao.set_err_state(params.platform_code, params.user_id, 0)
        if not res then
            ngx.log(ngx.ERR, "更新用戶账户错误状态失败: err=", err)
            return nil, "更新用戶账户错误状态失败"
        end
        return true, "处理成功"
    elseif sys.basedef.ACCOUNT_ERR_STATE.TRANSACTION_WATTING == params.err_state then
        --local res, err = monitor.handle_exception_transaction(params.user_id, params.platform_code)
        --if res then
        --    ngx.log(ngx.ERR, "用户存在未能处理的异常订单, 处理成功")
        --    return true, "处理成功"
        --else
        --    ngx.log(ngx.ERR, "用户存在未能处理的异常订单, 处理失败: err=", err)
        --    return nil, "用户存在未能处理的异常订单"
        --end
        ngx.log(ngx.ERR, "用户存在未能处理的异常订单.")
        return nil, "用户存在未能处理的异常订单."
    end
    ngx.log(ngx.ERR, "用户在第三方平台账户存在未定义错误：err_state=", params.err_state)
    return nil, "未知错误"
end


--[[
    免转模式：下分
]]
function _M.auto_transfer_out(app_id, biz_user_id, user_id, game_platform_code, self_configed, agent)
    local info, err = user_dao.get_record_login_info(user_id)
    if not info then
        ngx.log(ngx.ERR, "获取用户上一次游戏信息失败: err=", err)
        return sys.response(sys.ERR_CODE.SYS_ERR, "系统繁忙,请稍后再试.", err)
    end
    ngx.log(ngx.DEBUG, "获取用户上一次游戏信息:", sys.utils.json_encode(info))

    --获取该用户处理状态
    local state = tonumber(info.state) or 0
    if state ~= 0 then
        -- 数据异常，等待定时任务处理
        ngx.log(ngx.ERR, "用户上一次游戏状态异常: biz_user_id=", biz_user_id, ",user_id=", user_id, " state=", state)
        return sys.response(sys.ERR_CODE.USER_STATE_ERR, "用户在的状态信息异常.", info)
    end

    if not info.game_platform_code then
        return sys.response(sys.ERR_CODE.SUCCESS, "用户上一次游戏记录信息异常", { amount = 0, platform_code = info.game_platform_code })
    end

    local balance_temp = tonumber(info.balance) or 0
    --if balance_temp > 0 then
    --    return sys.response(200, "用户上一次游戏记录信息异常", { amount = balance_temp, platform_code = info.game_platform_code })
    --end

    if game_platform_code == info.game_platform_code then
        return sys.response(sys.ERR_CODE.SUCCESS, "用户上一次游戏记录和当前登录平台相同", { amount = balance_temp, platform_code = info.game_platform_code })
    end

    local agent_pre, err, is_self_configed = _M.get_platform_agent(info.game_platform_code, app_id)
    if not agent_pre then
        return sys.response(sys.ERR_CODE.SYS_ERR, "读取平台接入信息错误", { err = err })
    end

    agent_pre.self_configed = is_self_configed
    -- 查詢余额
    local params = {
        user_id = user_id,
        game_platform_code = info.game_platform_code,
        app_id = app_id,
        agent = agent_pre,
        self_configed = self_configed
    }
    local res, err = _M.capture_api(gapi_conf.METHOD.GET_BALANCE, params)
    if not res then
        ngx.log(ngx.ERR, "CAPTURE 查询余额失败: err=", err)
        return sys.response(sys.ERR_CODE.SYS_ERR, "从[" .. info.game_platform_code .. "]获取余额失败.", { err = err })
    end

    if 200 ~= res.code then
        ngx.log(ngx.ERR, "CAPTURE 查询余额 response=", sys.utils.json_encode(res))
        return sys.response(sys.ERR_CODE.SYS_ERR, "从[" .. info.game_platform_code .. "]获取余额失败.", res)
    end

    local balance = tonumber(res.data.balance) or 0
    ngx.log(ngx.ERR, "查询上一次的游戏平台余额, ", info.game_platform_code, ":", balance)

    if balance <= 0 then
        return sys.response(sys.ERR_CODE.SUCCESS, "", { amount = balance + balance_temp, platform_code = info.game_platform_code })
    end

    if balance + balance_temp <= 0 then
        --balance = tonumber(info.balance)
        return sys.response(sys.ERR_CODE.SUCCESS, "上一次的游戏平台余额为0.", { amount = 0, platform_code = info.game_platform_code })
    end

    -- 保存临时信息
    local temp = {
        game_platform_code = info.game_platform_code,
        balance = balance + balance_temp,
        state = 1
    }
    local res, err = user_dao.set_record_login_info(user_id, temp)
    if not res then
        ngx.log(ngx.ERR, "更新记录用户登录游戏信息失败: " .. err)
        return sys.response(sys.ERR_CODE.SYS_ERR, "系统繁忙,请稍后再试.", { err = err })
    end

    --不同游戏平台，从上一个平台下分
    local params = {
        --user_ip = post_data.user_ip,
        app_id = app_id,
        game_platform_code = info.game_platform_code,
        user_id = user_id,
        amount = balance,
        self_configed = self_configed,
        agent = agent_pre,
        order_no = incr_help.get_time_union_id(),
        admin = 1
    }

    --不同游戏平台，如果游戏平台余额为0 db中save_balance不为0，说明之前下分已经成功，由于后面上分失败导致，因此此时再次登录游戏，无需下分，直接上分即可
    local res, err = _M.capture_api(gapi_conf.METHOD.TAKE_NOW, params)
    if not res or res.code ~= 200 then
        ngx.log(ngx.ERR, "下分失败：res=", sys.utils.json_encode(res), ", params=", sys.utils.json_encode(params), ", err=", err)

        -- 下分失败，清理状态及缓存余额，下一次请求从游戏平台查询余额
        local login_info_tbl = {
            game_platform_code = info.game_platform_code,
            balance = balance_temp,
            state = 0,
        }
        return sys.response(sys.ERR_CODE.SYS_ERR, "从平台下分失败，需要更新用戶登入标记状态为0", { err = err, task_info = login_info_tbl })
    end
    ngx.log(ngx.ERR, "从平台[" .. info.game_platform_code .. "]下分成功: amount=", balance + balance_temp)
    return sys.response(sys.ERR_CODE.SUCCESS, "", { amount = balance + balance_temp, platform_code = info.game_platform_code })
end

function _M.get_platform_agent(platform_code, biz_id)
    local sql = ""
    if biz_id then
        sql = "SELECT A.self_configed, A.game_platform_agent_info, B.game_platform_json FROM t_bizorg_account A, t_three_gplatform_account B "
        sql = sql .. string.format("WHERE A.bizorg_id_fk='%s' AND A.game_platform_code='%s' AND B.game_platform_code_fk='%s';", biz_id, platform_code, platform_code)
    else
        sql = "SELECT B.game_platform_json FROM t_three_gplatform_account B "
        sql = sql .. string.format("WHERE B.game_platform_code_fk='%s';", platform_code)
    end
    local res, err = sys.db_mysql:query(sql)
    if not res then
        return nil, err
    end
    if not res[1] then
        ngx.log(ngx.ERR, "没有查询到游戏平台的信息,sql:", sql)
        return nil, string.format("查询渠道[%s]的平台[%s]账户信息无记录", biz_id, platform_code)
    end

    local data = res[1]
    if 1 == data.self_configed then
        if ngx.null == data.game_platform_agent_info or string.len(data.game_platform_agent_info) <= 0 then
            return nil, string.format("渠道[%s]对[%s]平台的接入信息配置错误", biz_id, platform_code)
        end
        local agent, err = sys.utils.json_decode(data.game_platform_agent_info)
        if not agent then
            return nil, string.format("渠道[%s]对[%s]平台的接入信息配置错误,需要JSON格式", biz_id, platform_code)
        else
            return agent, '获取渠道配置信息成功.', 1
        end
    else
        local agent, err = sys.utils.json_decode(data.game_platform_json)
        if not agent then
            return nil, string.format("[%s]平台的接入信息配置错误,,需要JSON格式", platform_code)
        else
            return agent, '获取平台配置信息成功.', 0
        end
    end
end


--[[
    Created by lixy at 2019-04-03 13:56
    @brief:  RSA 签名验证
    @params: 
        | args  | object | 签名验证参数

    @return: 
        $1: 错误码，200表示签名验证正确
        $2: 错误原因说明
]]
function _M.rsa_verify(app_id, args)
    local bizorg_dao = require("bizorg.model.bizorg_dao")
    local rsa = require "resty.utils.crypto.rsa"
    local sign_help = require "resty.utils.crypto.sign_help"

    -- BASE64解码的签名字符串
    local ok, sign_str = pcall(ngx.decode_base64, args.sign)
    if not ok then
        ngx.log(ngx.ERR, 'BASE64解码错误. args: ', sys.utils.json_encode(args))
        return sys.ERR_CODE.PARAM_ERR, "参数[sign]解码错误."
    end

    -- 读取RSA公钥， 渠道RSA信息保存在REDIS中，如果REDIS中未查询到，则到数据中进行查询
    local bizorg_rsa_pub = bizorg_dao.get_bizorg_rsa_keys1(app_id)
    if not bizorg_rsa_pub then
        ngx.log(ngx.ERR, '获取渠道用户[', app_id, ']公钥失败.')
        return sys.ERR_CODE.AUTHORIZATION_ERR, "获取渠道授权验证信息错误"
    end

    -- 将sign 字段设为空 生成待签名的组装字符串
    args.sign = nil 
    local un_signed_str = sign_help.make_sign_str_sort(args)

    --[[
        如果REDIS的公钥格式错误会导致 new_rsa_public 失败，如果失败则到数据库查询公钥同时更新REDIS的公钥
    ]]
    local public_cli = rsa:new_rsa_public(bizorg_rsa_pub, "SHA256")
    if public_cli then
        local res = public_cli:verify(un_signed_str, sign_str)
        if res then
            return sys.ERR_CODE.SUCCESS
        end
    end

    local res = bizorg_dao.delete_bizorg_rsa_keys1_cache(app_id)
    if res then
        local bizorg_rsa_pub = bizorg_dao.get_bizorg_rsa_keys1(app_id)
        if not bizorg_rsa_pub then
            ngx.log(ngx.ERR, '获取公钥信息失败.')
            return  sys.ERR_CODE.AUTHORIZATION_ERR, "获取渠道授权验证信息错误"
        end

        -- 系统默认使用 sha265 签名模式
        local public_cli = rsa:new_rsa_public(bizorg_rsa_pub, "SHA256")
        if not public_cli then
            ngx.log(ngx.ERR, '系统生成RSA验证信息失败.')
            return sys.ERR_CODE.AUTHORIZATION_ERR, "系统内部错误，授权验证失败,请稍后重试."
        end

        local res = public_cli:verify(un_signed_str, sign_str)
        if not res then
            ngx.log(ngx.ERR, " RSA签名：\n", bizorg_rsa_pub, "\n", un_signed_str)
            return sys.ERR_CODE.AUTHORIZATION_ERR, "授权验证信息失败."
        end
    else
        ngx.log(ngx.ERR, " RSA签名：\n", bizorg_rsa_pub, "\n", un_signed_str)
        return sys.ERR_CODE.AUTHORIZATION_ERR, "授权验证信息失败."
    end

    return sys.ERR_CODE.SUCCESS
end



function _M.check_platform(app_id, biz_user_id, platform_code)
    local result = {}

    -- 检查渠道在游戏平台的账户
    local res, err = bizorg_dao.get_account(app_id, platform_code)
    if not res then
        ngx.log(ngx.ERR, "获取渠道账户信息失败. error=", err)
        return sys.ERR_CODE.SYS_ERR, "系统错误"
    end
    if not res[1] then
        ngx.log(ngx.ERR, "渠道[", app_id, "]在平台[", platform_code, "]的账户不存在")
        return sys.ERR_CODE.BIZ_ACCOUNT_ERR, "渠道账户信息不存在"
    end
    result.biz_account = res[1]

    -- 检查游戏平台
    local res, err = game_platform_dao.get_platform(platform_code)
    if not res then
        ngx.log(ngx.ERR, "获取游戏平台" .. platform_code .. "信息失败. error=", err)
        return sys.ERR_CODE.SYS_ERR, "系统错误."
    end
    if not res[1] then
        return sys.ERR_CODE.PLATFORM_NOT_EXIST, "游戏平台不存在."
    end
    if type(res[1].platform_account_id_pk) == 'userdata' then
        return sys.ERR_CODE.SYS_ERR, "游戏平台账户数据不存在." 
    end
    result.platform = res[1]
    
    local agent_text = ""
    if result.biz_account.self_configed == 1 then 
        -- 使用渠道自己的游戏平台接入信息
        agent_text = result.biz_account.game_platform_agent_info
    else
        -- 使用系统的游戏平台接入信息
        agent_text = result.platform.game_platform_json
    end
    if type(agent_text) == 'userdata' or agent_text == "" then
        return sys.ERR_CODE.SYS_ERR, "游戏平台接入信息配置错误." 
    end

    local agent, err = sys.utils.json_decode(agent_text)
    if not agent then
        ngx.log(ngx.ERR, string.format("渠道使用游戏平台[%s]的接入信息配置错误，self_configed=%s, agent=%s", result.biz_account.self_configed, agent_text))
        return sys.ERR_CODE.SYS_ERR, "游戏平台接入信息配置错误."
    end
    result.agent = agent
    return sys.ERR_CODE.SUCCESS, "OK", result
end

return _M