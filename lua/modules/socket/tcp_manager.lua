---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by lixy.
--- DateTime: 2018/5/27 12:06
---

local ffi = require "ffi"
local cjson = require "cjson"
local sys = require("lua.server.sys")
local tcp_handler = require("lua.modules.socket.tcp_handler")

local sock = ngx.req.socket()
ngx.log(ngx.ERR, "\n\n===>> >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> TCP client connect.")

local handler = tcp_handler:new(sock)
handler:subscribe(sys.CHANNEL_TCP_PUBLIC)

--[[ ==============================================================================================
    TCP 连接处理

    TCP 通讯数据格式：  消息头 | 数据区 | CRC校验码 | 结束符

    消息头: 长度为13
        第1位：A3,
        第2位：A4
        第3位：子网/病区
        第4位：床位
        第5位：中继
        第6位：
        第7位：
        第8位：
        第9位：
        第10位：
        第11位：数据区长度
        第12位：指令控制码
    数据区：长度为消息头的第11位数值
    CRC校验码
    结束符：数值为16
]]

local head_len = 13
local ffi_buf = ffi.new("unsigned char[?]", 128)
--function ffi_read(buf, len)
--    ffi.copy(ffi_buf, buf, len)
--    return ffi_buf
--end


while true do
    if not sock then
        ngx.log(ngx.ERR, "===>> 000")
        return
    end

    -- sock:settimeout(0.1)
    -- 读取消息头
    local buf, err = sock:receive(head_len)
    if (buf) then
        ngx.log(ngx.ERR, "\n\n\n================================================================== [TCP]收到消息")

        -- 解析消息头数据，转换成LUA数据（number 数组）
        ffi.copy(ffi_buf, buf, head_len)
        local head = tcp_handler.convert(ffi_buf, head_len)
        ngx.log(ngx.ERR, "===>> 消息头： len=" .. head_len .. ", data= ", tcp_handler.bit_tostring(ffi_buf, head_len))

        --[[
            解析消息数据长度：
            消息头长度为13，第12位表示数据体长度，第13位表示指令码，第3位表示病区，第4位表示床位号，第5位表示中继号
        ]]
        local data_len = head[12] + 2

        -- 读取消息
        local buf, err = sock:receive(data_len)
        if buf then
            -- 解析数据体
            ffi.copy(ffi_buf, buf, data_len)
            local body = tcp_handler.convert(ffi_buf, data_len)

            -- 消息控制码: 消息头的最后一位
            local code = head[head_len]
            ngx.log(ngx.ERR, "===>> ON MESSAGE: MSG_ID=" .. code .. ", length=" .. data_len .. ", DATA: ", tcp_handler.bit_tostring(ffi_buf, data_len))

            -- 调用回调函数处理
            if handler[code] then
                handler[code](handler, code, head, data_len, body)
            else
                ngx.log(ngx.ERR, "===>> 未知消息：" .. code)
            end
        else
            ngx.log(ngx.ERR, "===>> Read data: buf_data is nil")
        end
    else
        if (err == "closed") then
            ngx.log(ngx.ERR, "===>> TCP closed")
            if (handler and handler.close) then
                handler.close(handler)
            end
            break
        elseif ("timeout" == err) then
        else
            ngx.log(ngx.ERR, "===>> Read data error: buf=nil, err=" .. err or "nil")
        end
    end
end

ngx.log(ngx.ERR, "===>> TCP thread end")
